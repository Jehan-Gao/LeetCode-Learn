## [LeetCode-680 验证回文数 ||](https://leetcode-cn.com/problems/valid-palindrome-ii/)

难度： 简单

类型： 字符串

### 题目：

给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

示例1：
```
输入: "aba"
输出: True
```

示例2：
```
输入: "abca"
输出: True
解释: 你可以删除c字符。
```


### 思路：

什么是回文字符串？

回文字符串就是从前和从后读，都是一模一样的。并且还有一个特点是：从这个字符串中间一分为二，
左右两边的内容上都是对称的。

利用上面的特性，我们可以分析：

我们可以利用双指针和它的对称性，一个指针从前移动，一个指针从后移动,如果两个指针指向的元素是相同的，
则指针继续移动。

直到两个指针指向的元素不同，我们就该尝试删除一个元素：
  - 尝试删除左指针指向的元素，(即左指针+1)，然后比较 [left+1, right] 的区间，
  看这个区间内的字符串左右两边是否相等，如果左右两边也相等，那么整个字符串就是回文字符串。
  - 还可以尝试删除右指针指向的元素，（即右指针-1），然后比较 [left, right-1] 的区间，
  看这个区间内的字符串左右两边是否相等，如果左右两边也相等，那么整个字符串就是回文字符串。
  - 如果 left+1 === right 或者 left === right-1, 则表示两个指针相遇，所指向的元素是同一个元素，
  这种情况，单字符元素也是回文字符串，那么整个字符串也是回文字符串。

### 实现：

javascript:

时间复杂度： O(n)

空间复杂度： O(1)

```js
function validPalindrome (s) {
  const len = s.length  

// 定义两个指针
  let j = 0
  let k = len - 1

// 如果j<k 并且两个指针指向的元素相同，就继续移动指针
  while (j < k && s[j] === s[k]) {
    j++
    k--
  }

// 跳过左指针指向的元素， 查看 [left+1, right]区间是否是回文字符串 
  if (isPalindrome(j+1, k)) {
    return true
  }
// 跳过右指针指向的元素，查看[left, right-1]区间是否是回文字符串
  if (isPalindrome(j, k-1)) {
    return true
  }

  // 工具函数 用来判断两个指针区间内的字符串是否是回文字符串
  function isPalindrome(left, right) {
    // 如果此时左指针还是小于右指针，说明两个指针之间还有其他的字符元素，继续循环
    while (left < right) {
      // 如果此时左指针指向的元素 不等于 右指针指向的元素 那么直接返回false, 
      // 整个字符串也肯定不是一个回文字符串。
      if (s[left] !== s[right]) {
        return false
      }
      left++
      right--
    }
    // 这里这种情况是 left === right 的情况，是单字符，肯定是回文字符串
    return true
  }

  // 默认返回false
  return false 
}

```
